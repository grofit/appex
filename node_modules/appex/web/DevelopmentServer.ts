// Copyright (c) 2013 haydn paterson (sinclair).  All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <referecne path="../references.ts" />
/// <reference path="../interfaces.ts" />
/// <reference path="../compiler/Compiler.ts" />
/// <reference path="../modules/IModule.ts" />
/// <reference path="../modules/Module.ts" />
/// <reference path="routing/IRouter.ts" />
/// <reference path="routing/Router.ts" />
/// <reference path="media/Mime.ts" />
/// <reference path="IContext.ts" />
/// <reference path="Context.ts" />
/// <reference path="IServer.ts" />
/// <reference path="ServerOptions.ts" />


module appex.web {

    /** a appex development server. manages JIT compilations on http request. */
    export class DevelopmentServer implements appex.web.IServer {

        private server                 : http.Server;

        private compiler               : appex.compiler.Compiler;

        private module                 : appex.modules.IModule;

        private router                 : appex.web.routing.IRouter;

        private mime                   : appex.web.media.Mime;

        private waiters                : appex.web.IContext[];
        
        private compiling              : boolean;
        
        /** arguments:
        *    options - server start options.
        */
        constructor(public options:appex.web.IServerOptions) {
            
            this.compiler              = new appex.compiler.Compiler();

            this.mime                  = new appex.web.media.Mime();

            this.module                = null;

            this.router                = null;

            this.waiters               = [];

            this.compiling             = false;

            this.options.stdout.write('appex \033[32m- development server\033[0m\n');
        }
        
        /** creates a nodejs http server based on the server options protocol.
         * 
         *  arguments:
         *      port - the port to listen on.
         */
        public listen(port:number) : void {
            
            var protocol:any = this.options.protocol == "http" ? node.http : node.https;

            var that = this;

            this.server = protocol.createServer(function(request : http.ServerRequest, response : http.ServerResponse, next : Function) : void {
            
                that.handler(request, response, null);
            });

            this.server.listen(port);
        }

        /** the http request handler.
        *   
        *   arguments:
        *       request  - the nodejs http request.
        *       response - the nodejs http response.
        *       next     - (optional) the next callback used for express / connect middleware.
        */       
        public handler (request:http.ServerRequest, response:http.ServerResponse, next?:Function) : void {
            
            var context = this.load_context(request, response, next);

            this.waiters.push( context );
            
            var that = this;

            this.compile(function(diagnostics) {

                if(diagnostics) {
                
                    that.errors(diagnostics);

                    return;
                }

                while(that.waiters.length > 0) {

                    var context = that.waiters.pop    ();
                    
                    context = that.load_context(request, response, next);

                    var handled = that.router.handler (context);

                    if(handled) {
                        
                        if(that.options.logging) {

                            var message = [];

                            message.push(context.request.method , ' ');

                            message.push(context.request.url, '\n');

                            that.options.stdout.write(message.join(''));
                        }
                    }
                    else 
                    {    
                        if(context.next) 
                        { 
                            context.next();
                        }
                    }
                }
            });
        }


        /** loads the context.
        *   
        *   arguments:
        *       request  - the nodejs http request
        *       response - the nodejs http response
        *       next     - the next function
        *       returns  - the context
        */   
        private load_context(request:http.ServerRequest, response:http.ServerResponse, next?:Function) : appex.web.IContext {

            var context       = new appex.web.Context();

            // bind in user objects.
            if(this.options.context) {

                for(var n in this.options.context) {
            
                    context[n] = this.options.context[n];
                }
            }

            // bind in context objects.
            context.request   = appex.web.BindRequest(request);

            context.response  = appex.web.BindResponse(response);

            context.next      = function() {};

            context.module    = this.module;

            context.router    = this.router;

            context.mime      = this.mime;

            if(next) {
            
                context.next = next;
            }

            // initialize the cascade.
            context.cascade = {};

            return context;
        }

        /** compiles options.program and loads the module and router.
        *   
        *   arguments:
        *       callback - a callback containing any diagnostics.
        */ 
        private compile ( callback: ( diagnostics:typescript.api.Diagnostic[] ) => void ): void {
        
            if(!this.compiling) {

                this.compiling = true;

                var that = this;

                this.compiler.compile(this.options.program, function(result) {
                    
                    that.compiling = false;

                    if(result.diagnostics.length > 0) {
                    
                        callback(result.diagnostics);

                        return;
                    }
                    
                    that.module     = new appex.modules.Module(result);

                    that.router     = new appex.web.routing.ModuleRouter(that.module);

                    callback(null);
                });
            }             
        }

        /** emits compilation errors to options.stdout and http buffer.
        *   
        *   arguments:
        *       diagnostics - the diagnostics to emit.
        */
        private errors  ( diagnostics:typescript.api.Diagnostic[] ) : void {
        
            while(this.waiters.length > 0) {

                var request = this.waiters.pop ();

                request.response.writeHead(500, {'content-type' : 'text/plain'});

                for(var n in diagnostics) {
                
                    var diagnostic = diagnostics[n];

                    var message = [];
                            
                    message.push( diagnostic.path )
                            
                    message.push(" [" , (diagnostic.line_index + 1).toString(),  ":" , (diagnostic.char_index + 1).toString() , "] ");
                            
                    message.push(diagnostic.message, '\n');

                    request.response.write(message.join(''));

                    if(this.options.logging) {

                        this.options.stderr.write( message.join('') );
                    }
                }

                request.response.end();
            }         
        }
        
        /** disposes of this server */
        public dispose  (): void {
        
            this.compiler.dispose();

            if(this.module) {
            
                this.module.dispose();
            }
        }
    }
}